# This shows how to find spatial data (e.g., shapefiles, geodatabases, etc.)
search_results = package_search(
q = "Pacific salmon",
fq = 'res_format:(SHP OR GDB OR GeoJSON OR KML OR CSV)' # CSV is sometimes spatial (lat/lon), sometimes not
)
################################################################################
### Plotting raster data
# This is actually raster data stored in a geodatabase. Which is a bit different to plot
# Remi's example shows how to plot tiff data. This is different
# If you read through the data, you'll see that that many types of data are availble for this (e.g., point data, raster, vector grid)
# The raster data I'm interested in is titled "surveyeffort"
# https://egisp.dfo-mpo.gc.ca/arcgis/rest/services/open_data_donnees_ouvertes/recreational_vessel_traffic_model_for_british_columbia/MapServer
# Follow steps above to create a temporary folder to download & extract geodatabase info
temp_dir = tempdir()
zip_file = file.path(temp_dir, "bc_boating_model.zip")
unzip_dir = file.path(temp_dir, "bc_boating_data")
# Download the dataset zip file
download.file(
url = "https://api-proxy.edh-cde.dfo-mpo.gc.ca/catalogue/records/fed5f00f-7b17-4ac2-95d6-f1a73858dac0/attachments/Recreational_Boating_Data_Model.gdb.zip",
destfile = zip_file,
mode = "wb"
)
# Unzip the contents
dir.create(unzip_dir, showWarnings = FALSE)
unzip(zip_file, exdir = unzip_dir)
# List the file names you just downloaded
boat_file = list.files(unzip_dir, full.names = TRUE)
# Turn the "survey effort" data into raster format
surveyRast = rast(boat_file, sub = "surveyeffort")
# Plot it just to see what it looks like
# It's gross! There are lots of values with no survey effort that make everything yucky to look at
plot(surveyRast)
# We need to fix up the data a bit more. First, unfortunately SpatRasters can't directly be plotted with ggplot
# So, we have to turn this into into a data frame
# But we can't do that directly, because the current projection is UTM, which means we'll lose lat/lon info
# So we first need to project it, so it's in the same CRS as the coast layer
# Use the project function to project to WGS 84 (i.e., the CRS of the coast file)
rast_proj = project(surveyRast, coast)
# Now turn the projected file into a dataframe
rast_df = as.data.frame(surveyRast, xy = TRUE)
df_filtered = rast_df[rast_df$Recreational_Boating_Data_Model > 0, ] # Filter out values with 0 survey effort
plot(rast_proj)
df = as.data.frame(coast_proj, xy = TRUE, na.rm = TRUE)
View(rast_proj)
# Plot it just to see what it looks like
# It's gross! There are lots of values with no survey effort that make everything yucky to look at
plot(surveyRast)
# You'll see this also fixes the issue of no data
plot(rast_proj)
rast_df = as.data.frame(coast_proj, xy = TRUE, na.rm = TRUE)
rast_df = as.data.frame(rast_proj, xy = TRUE, na.rm = TRUE)
rast_df = as.data.frame(rast_proj, xy = TRUE)
rast_df = as.data.frame(rast_proj)
View(rast_df)
# Use the project function to project to WGS 84 (i.e., the CRS of the coast file)
rast_proj = project(surveyRast, coast)
# You'll see this also fixes the issue of no data. Things get cleared up!
plot(rast_proj)
#
rast_df = as.data.frame(rast_proj, xy = TRUE)
View(rast_proj)
View(rast_df)
ggplot()+
geom_tile(data = rast_df, aes(x=x, y=y, fill = Recreational_Boating_Data_Model)) +
geom_sf(data = coast, fill = "lightgrey")+
scale_fill_viridis_c(option = "magma")+
coord_sf(
xlim = c(bounds["xmin"], bounds["xmax"]),
ylim = c(bounds["ymin"], bounds["ymax"])
)+
theme_bw()
leaflet() %>%
addProviderTiles(providers$Esri.OceanBasemap) %>%
addRasterImage(rast_proj, colors = pal, opacity = 0.7, project = T) %>%
addLegend(pal = pal, values = values(hi_leaf),
title = "Boating Effort",
position = "bottomright")
# Step 2: Convert raster to leaflet-compatible format
pal <- colorNumeric(palette = "magma", domain = values(rast_proj), na.color = "transparent")
# Step 3: Create leaflet map
leaflet() %>%
addProviderTiles(providers$Esri.OceanBasemap) %>%
addRasterImage(rast_proj, colors = pal, opacity = 0.7, project = T) %>%
addLegend(pal = pal, values = values(rast_proj),
title = "Boating Effort",
position = "bottomright")
View(rast_df)
rast_df = as.data.frame(rast_proj, xy = TRUE) %>%
filter(Recreational_Boating_Data_Model != 1)
ggplot()+
geom_tile(data = rast_df, aes(x=x, y=y, fill = Recreational_Boating_Data_Model)) +
geom_sf(data = coast, fill = "lightgrey")+
scale_fill_viridis_c(option = "magma")+
coord_sf(
xlim = c(bounds["xmin"], bounds["xmax"]),
ylim = c(bounds["ymin"], bounds["ymax"])
)+
theme_bw()
rast_proj[rast_proj == 1] <- NA
leaflet() %>%
addProviderTiles(providers$Esri.OceanBasemap) %>%
addRasterImage(rast_proj, colors = pal, opacity = 0.7, project = T) %>%
addLegend(pal = pal, values = values(rast_proj),
title = "Boating Effort",
position = "bottomright")
pfmas = get_spatial_layer("https://egisp.dfo-mpo.gc.ca/arcgis/rest/services/open_data_donnees_ouvertes/pacific_commercial_salmon_in_season_catch_estimates_en/MapServer/3")
View(pfmas)
pfmas = get_spatial_layer("https://egisp.dfo-mpo.gc.ca/arcgis/rest/services/open_data_donnees_ouvertes/pacific_commercial_salmon_in_season_catch_estimates_en/MapServer/3")
View(pfmas)
troll = get_spatial_layer("https://egisp.dfo-mpo.gc.ca/arcgis/rest/services/open_data_donnees_ouvertes/pacific_commercial_salmon_in_season_catch_estimates_en/MapServer/1", where = "CALENDAR_YEAR = 2008")
View(troll)
pfmas = get_spatial_layer("https://egisp.dfo-mpo.gc.ca/arcgis/rest/services/open_data_donnees_ouvertes/pacific_commercial_salmon_in_season_catch_estimates_en/MapServer/3")
pfmas = get_spatial_layer("https://egisp.dfo-mpo.gc.ca/arcgis/rest/services/open_data_donnees_ouvertes/pacific_commercial_salmon_in_season_catch_estimates_fr/MapServer/3")
# Load required package
library(esri2sf)
install.packages("esri2sf")
layer_url <- "https://egisp.dfo-mpo.gc.ca/arcgis/rest/services/open_data_donnees_ouvertes/pacific_commercial_salmon_in_season_catch_estimates_fr/MapServer/3"
# Try to get the spatial layer
pfmas <- get_spatial_layer(layer_url)
View(pfmas)
library(raster)      # For raster data handling
library(terra)       # Alternative to raster
library(rayshader)   # For hillshade generation
install.packages("raser")
install.packages("raster")
install.packages("terra")
install.packages("raster")
install.packages("raster")
install.packages("terra")
install.packages("rayshader")
install.packages("ggplot2")
install.packages("ggspatial")
library(raster)      # For raster data handling
library(terra)       # Alternative to raster
library(rayshader)   # For hillshade generation
library(ggplot2)     # For plotting
library(ggspatial)   # Optional: for scale bar and north arrow
# Load bathymetry raster
bathy = raster("C:\Users\FINNISS\Desktop\Bathymetry\NONNA100_4900N12400W.tiff")
# Load bathymetry raster
bathy = raster("C:/Users/FINNISS/Desktop/Bathymetry/NONNA100_4900N12400W.tiff")
# Convert to matrix for rayshader
bathy_mat = raster_to_matrix(bathy)
# Generate hillshade
hillshade = ray_shade(bathy_mat, sunaltitude = 45, sunangle = 315, zscale = 1)
hillshade_raster = raster(hillshade)
extent(hillshade_raster) = extent(bathy)
crs(hillshade_raster) = crs(bathy)
# Plot using ggplot2
bathy_df <- as.data.frame(bathy, xy = TRUE)
hill_df <- as.data.frame(hillshade_raster, xy = TRUE)
ggplot() +
geom_raster(data = hill_df, aes(x = x, y = y, fill = layer)) +
scale_fill_gradient(low = "grey10", high = "grey90") +
geom_raster(data = bathy_df, aes(x = x, y = y, fill = layer), alpha = 0.7) +
scale_fill_viridis_c(option = "C") +
coord_equal() +
theme_minimal()
install.packages("ggnewscale")
library(ggnewscale)
# Load bathymetry raster
bathy <- raster("C:/Users/FINNISS/Desktop/Bathymetry/NONNA100_4900N12400W.tiff")
# Convert to matrix for rayshader
bathy_mat <- raster_to_matrix(bathy)
# Generate hillshade
hillshade <- ray_shade(bathy_mat, sunaltitude = 45, sunangle = 315, zscale = 1)
# Convert hillshade to raster
hillshade_raster <- raster(hillshade)
extent(hillshade_raster) <- extent(bathy)
crs(hillshade_raster) <- crs(bathy)
# Convert both rasters to data frames
bathy_df <- as.data.frame(bathy, xy = TRUE)
colnames(bathy_df)[3] <- "bathy"
hill_df <- as.data.frame(hillshade_raster, xy = TRUE)
colnames(hill_df)[3] <- "shade"
# Plot using ggplot2 with separate fill scales
ggplot() +
geom_raster(data = hill_df, aes(x = x, y = y, fill = shade)) +
scale_fill_gradient(low = "grey10", high = "grey90", name = "Hillshade") +
new_scale_fill() +  # Allows a second fill scale
geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy), alpha = 0.7) +
scale_fill_viridis_c(name = "Bathymetry") +
coord_equal() +
theme_minimal()
ggplot() +
geom_raster(data = hill_df, aes(x = x, y = y, fill = shade)) +
scale_fill_gradient(low = "grey10", high = "grey90", name = "Hillshade") +
new_scale_fill() +  # Allows a second fill scale
#geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy), alpha = 0.7) +
#scale_fill_viridis_c(name = "Bathymetry") +
coord_equal() +
theme_minimal()
ggplot() +
#geom_raster(data = hill_df, aes(x = x, y = y, fill = shade)) +
#scale_fill_gradient(low = "grey10", high = "grey90", name = "Hillshade") +
new_scale_fill() +  # Allows a second fill scale
geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy), alpha = 0.7) +
scale_fill_viridis_c(name = "Bathymetry") +
coord_equal() +
theme_minimal()
bathy_mat[bathy_may >0] = NA
bathy_mat[bathy_mat >0] = NA
# Generate hillshade
hillshade <- ray_shade(bathy_mat, sunaltitude = 45, sunangle = 315, zscale = 1)
# Convert hillshade to raster
hillshade_raster <- raster(hillshade)
extent(hillshade_raster) <- extent(bathy)
crs(hillshade_raster) <- crs(bathy)
# Convert both rasters to data frames
bathy_df <- as.data.frame(bathy, xy = TRUE)
colnames(bathy_df)[3] <- "bathy"
hill_df <- as.data.frame(hillshade_raster, xy = TRUE)
colnames(hill_df)[3] <- "shade"
# Plot using ggplot2 with separate fill scales
ggplot() +
#geom_raster(data = hill_df, aes(x = x, y = y, fill = shade)) +
#scale_fill_gradient(low = "grey10", high = "grey90", name = "Hillshade") +
new_scale_fill() +  # Allows a second fill scale
geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy), alpha = 0.7) +
scale_fill_viridis_c(name = "Bathymetry") +
coord_equal() +
theme_minimal()
# Convert to matrix for rayshader
bathy_mat <- raster_to_matrix(bathy)
# Generate hillshade
hillshade <- ray_shade(bathy_mat, sunaltitude = 45, sunangle = 315, zscale = 1)
# Convert hillshade to raster
hillshade_raster <- raster(hillshade)
extent(hillshade_raster) <- extent(bathy)
crs(hillshade_raster) <- crs(bathy)
# Convert both rasters to data frames
bathy_df <- as.data.frame(bathy, xy = TRUE)
colnames(bathy_df)[3] <- "bathy"
hill_df <- as.data.frame(hillshade_raster, xy = TRUE)
colnames(hill_df)[3] <- "shade"
# Plot using ggplot2 with separate fill scales
ggplot() +
#geom_raster(data = hill_df, aes(x = x, y = y, fill = shade)) +
#scale_fill_gradient(low = "grey10", high = "grey90", name = "Hillshade") +
new_scale_fill() +  # Allows a second fill scale
geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy), alpha = 0.7) +
scale_fill_viridis_c(name = "Bathymetry") +
coord_equal() +
theme_minimal()
ggplot() +
geom_raster(data = hill_df, aes(x = x, y = y, fill = shade)) +
scale_fill_gradient(low = "grey10", high = "grey90", name = "Hillshade") +
#new_scale_fill() +  # Allows a second fill scale
#geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy), alpha = 0.7) +
#scale_fill_viridis_c(name = "Bathymetry") +
coord_equal() +
theme_minimal()
bathy_mat <- bathy_mat[nrow(bathy_mat):1, ]  # Flip vertically
# Generate hillshade
hillshade <- ray_shade(bathy_mat, sunaltitude = 45, sunangle = 315, zscale = 1)
# Convert hillshade to raster
hillshade_raster <- raster(hillshade)
extent(hillshade_raster) <- extent(bathy)
crs(hillshade_raster) <- crs(bathy)
# Convert both rasters to data frames
bathy_df <- as.data.frame(bathy, xy = TRUE)
colnames(bathy_df)[3] <- "bathy"
hill_df <- as.data.frame(hillshade_raster, xy = TRUE)
colnames(hill_df)[3] <- "shade"
# Plot using ggplot2 with separate fill scales
ggplot() +
geom_raster(data = hill_df, aes(x = x, y = y, fill = shade)) +
scale_fill_gradient(low = "grey10", high = "grey90", name = "Hillshade") +
#new_scale_fill() +  # Allows a second fill scale
#geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy), alpha = 0.7) +
#scale_fill_viridis_c(name = "Bathymetry") +
coord_equal() +
theme_minimal()
# Compute slope and aspect
slope <- terrain(bathy, opt = "slope", unit = "radians")
aspect <- terrain(bathy, opt = "aspect", unit = "radians")
# Create hillshade
hill <- hillShade(slope, aspect, angle = 45, direction = 315)
# Convert to data frames for ggplot
bathy_df <- as.data.frame(bathy, xy = TRUE)
colnames(bathy_df)[3] <- "bathy"
hill_df <- as.data.frame(hill, xy = TRUE)
colnames(hill_df)[3] <- "shade"
# Plot with ggplot2
ggplot() +
geom_raster(data = hill_df, aes(x = x, y = y, fill = shade)) +
scale_fill_gradient(low = "grey10", high = "grey90", name = "Hillshade") +
new_scale_fill() +
geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy), alpha = 0.7) +
scale_fill_viridis_c(name = "Bathymetry") +
coord_equal() +
theme_minimal()
ggplot() +
geom_raster(data = hill_df, aes(x = x, y = y, fill = shade)) +
scale_fill_gradient(low = "grey10", high = "grey90", name = "Hillshade") +
new_scale_fill() +
geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy), alpha = 0.9) +
scale_fill_viridis_c(name = "Bathymetry") +
coord_equal() +
theme_minimal()
ggplot() +
#geom_raster(data = hill_df, aes(x = x, y = y, fill = shade)) +
#scale_fill_gradient(low = "grey10", high = "grey90", name = "Hillshade") +
new_scale_fill() +
geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy), alpha = 0.9) +
scale_fill_viridis_c(name = "Bathymetry") +
coord_equal() +
theme_minimal()
ggplot() +
geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy), alpha = 0.9) +
scale_fill_viridis_c(name = "Bathymetry")
ggplot() +
geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy), alpha = 0.3) +
scale_fill_viridis_c(name = "Bathymetry")
ggplot() +
geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy), alpha = 0.3) +
scale_fill_viridis_c(name = "Bathymetry")
geom_raster(data = hill_df, aes(x = x, y = y, fill = shade)) +
scale_fill_gradient(low = "grey10", high = "grey90", name = "Hillshade") +
new_scale_fill() +
coord_equal() +
theme_minimal()
ggplot() +
geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy), alpha = 0.3) +
scale_fill_viridis_c(name = "Bathymetry") +
geom_raster(data = hill_df, aes(x = x, y = y, fill = shade)) +
scale_fill_gradient(low = "grey10", high = "grey90", name = "Hillshade") +
new_scale_fill() +
coord_equal() +
theme_minimal()
ggplot() +
#geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy), alpha = 0.3) +
#scale_fill_viridis_c(name = "Bathymetry") +
geom_raster(data = hill_df, aes(x = x, y = y, fill = shade)) +
scale_fill_gradient(low = "grey10", high = "grey90", name = "Hillshade") +
new_scale_fill() +
coord_equal() +
theme_minimal()
ggplot() +
geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy) +
scale_fill_viridis_c(name = "Bathymetry")
# Plot with ggplot2
ggplot() +
geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy) +
scale_fill_viridis_c(name = "Bathymetry")
ggplot() +
geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy)
ggplot() +
geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy)) +
scale_fill_viridis_c(name = "Bathymetry")
ggplot() +
#geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy)) +
# scale_fill_viridis_c(name = "Bathymetry") +
geom_raster(data = hill_df, aes(x = x, y = y, fill = shade)) +
scale_fill_gradient(low = "grey10", high = "grey90", name = "Hillshade")
# Keep original longitude bounds, but set ymax to 47.6
crop_extent <- extent(bathy@extent@xmin, bathy@extent@xmax, bathy@extent@ymin, 47.6)
# Define corrected extent
crop_extent <- extent(xmin(bathy), xmax(bathy), ymin(bathy), 47.6)
# Define corrected extent
crop_extent <- extent(xmin(bathy), xmax(bathy), ymin(bathy), 49.6)
# Crop the raster
bathy_cropped <- crop(bathy, crop_extent
# Define corrected extent
crop_extent <- extent(xmin(bathy), xmax(bathy), ymin(bathy), 49.6)
# Crop the raster
bathy_cropped <- crop(bathy, crop_extent)
bathy = bathy_cropped
# Compute slope and aspect
slope <- terrain(bathy, opt = "slope", unit = "radians")
aspect <- terrain(bathy, opt = "aspect", unit = "radians")
# Create hillshade
hill <- hillShade(slope, aspect, angle = 45, direction = 315)
# Convert to data frames for ggplot
bathy_df <- as.data.frame(bathy, xy = TRUE)
colnames(bathy_df)[3] <- "bathy"
hill_df <- as.data.frame(hill, xy = TRUE)
colnames(hill_df)[3] <- "shade"
# Plot with ggplot2
ggplot() +
#geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy)) +
# scale_fill_viridis_c(name = "Bathymetry") +
geom_raster(data = hill_df, aes(x = x, y = y, fill = shade)) +
scale_fill_gradient(low = "grey10", high = "grey90", name = "Hillshade") +
new_scale_fill() +
coord_equal() +
theme_minimal()
# Plot with ggplot2
ggplot() +
geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy), alpha = 0.2) +
scale_fill_viridis_c(name = "Bathymetry") +
geom_raster(data = hill_df, aes(x = x, y = y, fill = shade)) +
scale_fill_gradient(low = "grey10", high = "grey90", name = "Hillshade") +
new_scale_fill() +
coord_equal() +
theme_minimal()
ggplot() +
# First layer: hillshade
geom_raster(data = hill_df, aes(x = x, y = y, fill = shade)) +
scale_fill_gradient(low = "grey10", high = "grey90", name = "Hillshade") +
# Declare new fill scale
new_scale_fill() +
# Second layer: bathymetry with transparency
geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy), alpha = 0.7) +
scale_fill_viridis_c(name = "Bathymetry") +
coord_equal() +
theme_minimal()
ggplot() +
# First layer: hillshade
geom_raster(data = hill_df, aes(x = x, y = y, fill = shade)) +
scale_fill_gradient(low = "grey10", high = "grey90", name = "Hillshade") +
# Declare new fill scale
new_scale_fill() +
# Second layer: bathymetry with transparency
geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy), alpha = 0.7) +
scale_fill_viridis_c(name = "Bathymetry") +
coord_equal() +
theme_minimal()
# Load bathymetry raster
bathy = raster("C:/Users/FINNISS/Desktop/Bathymetry/NONNA100_4900N12400W.tiff")
# Load bathymetry raster
bathy = raster("C:/Users/FINNISS/Desktop/Bathymetry/NONNA100_4900N12400W.tiff")
# Convert to data frames for ggplot
bathy_df = as.data.frame(bathy, xy = TRUE)
colnames(bathy_df)[3] <- "bathy"
ggplot() +
geom_raster(data = bathy_df, aes(x = x, y = y, fill = bathy)) +
scale_fill_viridis_c(name = "Bathymetry") +
coord_equal() +
theme_minimal()
install.packages("librarian")
library("librarian")
librarian::shelf(
Microsoft365R,
readxl,
dplyr,
purrr
)
# Optional: Clear cached authentication tokens if needed
# AzureAuth::clean_token_directory()
# Connect to the SharePoint site
site = get_sharepoint_site("Fishery & Assessment Data Section Wiki")
# Optional: Clear cached authentication tokens if needed
AzureAuth::clean_token_directory()
# Access the document library
doclib = site$get_drive("Documents")
# Connect to the SharePoint site
site = get_sharepoint_site("Fishery & Assessment Data Section Wiki")
# Access the document library
doclib = site$get_drive("Documents")
# Locate the file by its relative path
file = doclib$get_item("General/Pacific Salmon Data Community of Practice/Projects & Task Teams/Reproducible Data Products/Salmon Outlook Reporting/Background Research/outlook_phase1_test_dummy_data_20250905.xlsx")
# Download the file to a temporary location
temp_path = tempfile(fileext = ".xlsx")
file$download(temp_path)
# List all sheet names
sheet_names = readxl::excel_sheets(temp_path)
# Read each sheet and name the list elements
df_list = map(sheet_names, ~ read_excel(temp_path, sheet = .x)) %>%
set_names(sheet_names)
# Export each dataframe to the global environment
list2env(df_list, envir = .GlobalEnv)
# Columns we want to keep (now using parentrowid instead of uniquerowid)
keep_cols_repeat = c(
"globalid", "uniquerowid",
"smu_area", "smu_species", "smu_name",
"outlook_narrative", "smu_outlook_assignment", "smu_prelim_forecast"
)
keep_cols_cu = c(
"cu_outlook_selection", "cu_outlook_assignment", "cu_prelim_forecast", "cu_count",
"parentrowid"
)
keep_cols_other = c(
"other_outlook_selection", "other_outlook_assignment", "other_prelim_forecast", "parentrowid"
)
Outlook_Repeat_Test = Outlook_Repeat_Test %>%
select(all_of(keep_cols_repeat))
cu_outlook_records = cu_outlook_records %>%
select(all_of(keep_cols_cu))
other_outlook_records = other_outlook_records %>%
select(all_of(keep_cols_other))
# Step 2: Join smu_area, smu_species, smu_name from Outlook_Repeat_Test to cu_outlook_records
cu_outlook_records_enriched = cu_outlook_records %>%
left_join(
Outlook_Repeat_Test %>%
select(uniquerowid, smu_area, smu_species, smu_name),
by = c("parentrowid" = "uniquerowid")
)
# Step 2: Join smu_area, smu_species, smu_name from Outlook_Repeat_Test to cu_outlook_records
other_outlook_records_enriched = other_outlook_records %>%
left_join(
Outlook_Repeat_Test %>%
select(uniquerowid, smu_area, smu_species, smu_name),
by = c("parentrowid" = "uniquerowid")
)
View(other_outlook_records)
tinytex::tlmgr_install('babel-french')
tinytex::reinstall_tinytex(repository = "illinois")
tinytex::tlmgr_install('babel-english')
install.packages("remotes")
remotes::install_github("pbs-assess/csasdown", dependencies = TRUE)
setwd("C:/Users/FINNISS/Desktop/csasdownTests")
csasdown::dratf("techreport")
csasdown::draft("techreport")
---
title: 'WCVI Chinook Table'
csasdown::draft("techreport")
install.packages("flextable")
install.packages("flextable")
library("flextable")
install.packages("officer")
install.packages("officer")
